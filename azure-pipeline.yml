pool:
  vmImage: ubuntu-latest

trigger:
  batch: true
  branches:
    include:
      - review/*
      - refs/tags/*
      - main
    exclude:
      - refs/tags/tf-*
  paths:
    exclude:
      - terraform

pr:
  branches:
    include:
    - '*'
  paths:
    exclude:
      - terraform

schedules:
  - cron: '0 4 * * *'
    displayName: Daily build
    always: true
    branches:
      include:
        - main

parameters:
  - name: dryRun
    displayName: Dry Run
    type: boolean
    default: false
  - name: deployReview
    displayName: Force Deploy Review
    type: boolean
    default: false
  - name: deployIntegration
    displayName: Force Deploy Integration
    type: boolean
    default: false
  - name: deployStaging
    displayName: Force Deploy Staging
    type: boolean
    default: false
  - name: deployProduction
    displayName: Force Deploy Production
    type: boolean
    default: false
  - name: deployDr
    displayName: Force Deploy DisasterRecovery
    type: boolean
    default: false
  - name: debug
    displayName: Debug (forced false in production)
    type: boolean
    default: false
  - name: tags
    displayName: Frontend test tags (default Smoke)
    type: string
    default: Smoke

resources:
  repositories:
    - repository: wagtail-container-apps
      type: github
      name: nhsuk/dct.terraform-modules.wagtail-container-apps
      endpoint: nhsuk (1)

variables:
  - name: sourceBranchName
    ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
      value: pr-$(System.PullRequest.PullRequestNumber)
    ${{ else }}:
      value: $(Build.SourceBranchName)

stages:
  - stage: PrepareAndTest
    displayName: Prepare & Unit Test
    jobs:
      - job: test
        displayName: Prepare & Unit Test
        steps:
          - template: azure-pipeline-templates/test.yml

  - stage: Build
    displayName: Build
    dependsOn: PrepareAndTest
    condition: succeeded()
    jobs:
      - job: buildReview
        displayName: Build Review
        dependsOn: []
        condition: or(startsWith(variables['Build.SourceBranch'], 'refs/heads/review/'), eq(variables['Build.Reason'], 'PullRequest'), ${{ parameters.deployReview }})
        steps:
          - template: azure-pipeline-templates/build.yml
            parameters:
              tag: 'review-$(sourceBranchName)'
              dryRun: ${{ parameters.dryRun }}
      - job: buildIntegration
        displayName: Build Integration
        condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), ${{ parameters.deployIntegration }})
        steps:
          - template: azure-pipeline-templates/build.yml
            parameters:
              tag: latest
              dryRun: ${{ parameters.dryRun }}
      - job: buildStaging
        displayName: Build Staging
        condition: or(startsWith(variables['Build.SourceBranch'], 'refs/tags/'), ${{ parameters.deployStaging }})
        dependsOn: []
        steps:
          - template: azure-pipeline-templates/build.yml
            parameters:
              tag: $(sourceBranchName)
              dryRun: ${{ parameters.dryRun }}

  - stage: Deploy
    displayName: Deploy
    dependsOn: Build
    jobs:
      - job: Review
        condition: and(succeeded(), or(startsWith(variables['Build.SourceBranch'], 'refs/heads/review/'), eq(variables['Build.Reason'], 'PullRequest'), ${{ parameters.deployReview }}))
        variables:
          - group: Review
          - group: alerting
          - name: environment
            value: dev
          - name: region
            value: uks
          - name: devInstance
            ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
              value: pr-$(System.PullRequest.PullRequestNumber)
            ${{ else }}:
              value: $[lower(variables['Build.SourceBranchName'])]
          - name: tag
            value: $(Build.SourceVersion)
        steps:
          - checkout: self
            workspaceRepo: true

          - checkout: wagtail-container-apps
            persistCredentials: true
            fetchDepth: 1

          - script: |
              tail -n 2 $(Pipeline.Workspace)/s/dct.terraform-modules.wagtail-container-apps/.git/config >> ~/.gitconfig
            displayName: Git auth

          - task: JasonBJohnson.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@2
            displayName: Install latest Terraform

          - task: JasonBJohnson.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@2
            displayName: Initialise
            inputs:
              command: init
              workingDirectory: terraform/src/review
              backendType: azurerm
              backendServiceArm: dct-crccms-dev
              backendAzureRmResourceGroupName: dct-crccms-platform-rg-$(environment)-$(region)
              backendAzureRmStorageAccountName: crccmstfst$(environment)$(region)
              backendAzureRmKey: terraform-$(devInstance)-apps.tfstate

          - script: |
              set -ex
              export url=$(terraform output -raw url)
              if [[ "$url" == https* ]]; then
                echo "##vso[task.setvariable variable=existingDeployment]true"
              fi
            name: existingDeployment
            displayName: Existing deployment check
            workingDirectory: terraform/src/review

          - task: AzureKeyVault@2
            displayName: 'Azure Key Vault: Database'
            condition: and(succeeded(), ne(variables['existingDeployment'], true))
            inputs:
              azureSubscription: dct-crccms-dev
              KeyVaultName: dct-crc-kv-app-dev-uks
              SecretsFilter: default--db-name, default--db-host, default--db-user

          - task: AzureKeyVault@2
            displayName: 'Azure Key Vault: Admin'
            condition: and(succeeded(), ne(variables['existingDeployment'], true))
            inputs:
              azureSubscription: dct-crccms-dev
              KeyVaultName: dct-crccms-kv2-dev-uks
              SecretsFilter: postgresqlAdminUser, postgresqlAdminPassword

          - script: |
              set -e
              docker run \
                -e PGHOST="$(default--db-host)" \
                -e PGUSER="$(postgresqlAdminUser)" \
                -e PGPASSWORD \
                postgres:16 \
                psql -d "$(default--db-name)" \
                -v ON_ERROR_STOP=off \
                -c "SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE pg_stat_activity.datname = '$(default--db-name)' AND pid <> pg_backend_pid();" \
                -c "CREATE DATABASE \"$(devInstance)\" WITH TEMPLATE $(default--db-name) OWNER $(default--db-user);" \
                -c "\connect \"$(devInstance)\";"
            displayName: Create review database
            condition: and(succeeded(), ne('${{ lower(parameters.dryRun) }}', 'true'), ne(variables['existingDeployment'], true))
            env:
              PGPASSWORD: $(postgresqlAdminPassword)

          - task: AzureCLI@2
            displayName: Copy default app config
            condition: and(succeeded(), ne('${{ lower(parameters.dryRun) }}', 'true'), ne(variables['existingDeployment'], true))
            inputs:
              azureSubscription: dct-crccms-dev
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                set -e
                SECRET_NAMES=$(az keyvault secret list --vault-name $VAULT_NAME --query "[?starts_with(name,'default--')].name" --output tsv)
                while read secret
                do
                  VALUE=$(az keyvault secret show --vault-name $VAULT_NAME --name $secret --query "value" --output tsv)
                  if [ -z "${VALUE}" ]; then
                    az keyvault secret set --vault-name $VAULT_NAME --name ${secret/default/"$DEV_INSTANCE"} --file /dev/null --query "name"
                  else
                    az keyvault secret set --vault-name $VAULT_NAME --name ${secret/default/"$DEV_INSTANCE"} --value "${VALUE}" --query "name"
                  fi
                done <<< "$SECRET_NAMES"
                az keyvault secret set --vault-name $VAULT_NAME --name "$DEV_INSTANCE--db-name" --value $DEV_INSTANCE --query "name"
            env:
              VAULT_NAME: dct-crc-kv-app-dev-uks
              DEV_INSTANCE: $(devInstance)
              ENVIRONMENT: $(environment)
              REGION: $(region)

          - task: JasonBJohnson.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@2
            displayName: Plan
            inputs:
              command: plan
              workingDirectory: terraform/src/review
              environmentServiceName: dct-crccms-dev
              commandOptions: >
                -var dev_instance=$(devInstance)
                -var crc_cms_version=$(tag)
                -var username=$(AUTH_USERNAME)
                -var sha_512_password=$(AUTH_PASSWORD_SHA_512)
                -out=$(System.DefaultWorkingDirectory)/terraform.tfplan
                -detailed-exitcode
              publishPlanResults: $(environment)_plan

          - ${{ if eq(lower(parameters.dryRun), 'true') }}:
              - script: |
                  echo "##vso[task.logissue type=warning;]Running in dryrun mode - skipping apply step"
                  echo "##vso[task.complete result=SucceededWithIssues;]"
                displayName: Dry Run - skipping apply

          - task: JasonBJohnson.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@2
            displayName: Apply
            condition: and(succeeded(), eq(variables['TERRAFORM_PLAN_HAS_CHANGES'], 'true'), ne('${{ lower(parameters.dryRun) }}', 'true'))
            inputs:
              command: apply
              workingDirectory: terraform/src/review
              environmentServiceName: dct-crccms-dev
              commandOptions: $(System.DefaultWorkingDirectory)/terraform.tfplan

          - script: |
              set -ex
              URL="$(terraform output -raw url)"
              echo "##vso[task.setvariable variable=BASE_URL;isOutput=true]${URL}"
            name: terraformOutput
            displayName: Get Base URL
            workingDirectory: terraform/src/review

          - template: azure-pipeline-templates/run-init-container-app-job.yml
            parameters:
              env: dev
              version: $(tag)
              devInstance: $(devInstance)
              dryrun: ${{ parameters.dryRun }}

          - template: ./azure-pipeline-templates/deploy-container-app-revision.yml
            parameters:
              env: dev
              version: $(tag)
              devInstance: $(devInstance)
              dryrun: ${{ parameters.dryrun }}

          - script: |
              echo "Sending slack notification for branch $(sourceBranchName)"
              echo "Review Url: $(terraformOutput.BASE_URL)"
              messageText="`if [[ '${{ parameters.dryrun }}' == 'True' ]]; then printf %s 'THIS IS A DRYRUN\n'; fi`
                      Campaign Resource Centre: A new review environment has been deployed for $(Build.RequestedFor).
                      \nBranch: $(sourceBranchName)
                      \nURL: $(terraformOutput.BASE_URL)"
              body="{\"text\": \"$messageText\", \"mrkdwn\": true}"
              curl -X POST -H 'Content-type: application/json' --data "$body" $(notificationSlackWebhook)
            displayName: Send Slack Notification
            condition: and(succeeded(), ne(variables['existingDeployment'], 'true'))
          - ${{ if ne('${{ lower(parameters.dryRun) }}', 'true') }}:
            - template: azure-pipeline-templates/frontendtest.yml
              parameters:
                authorize: STAGING_AUTHORIZATION
                baseUrl: $(terraformOutput.BASE_URL)
                tags: ${{ parameters.tags }}

      - job: deployIntegration
        displayName: Deploy Integration
        condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), ${{ parameters.deployIntegration }})
        variables:
          - group: Integration
        steps:
          - template: azure-pipeline-templates/run-init-container-app-job.yml
            parameters:
              env: int
              version: $(Build.SourceVersion)
              dryrun: ${{ parameters.dryrun }}
          - template: azure-pipeline-templates/deploy-container-app-revision.yml
            parameters:
              env: int
              version: $(Build.SourceVersion)
              dryrun: ${{ parameters.dryrun }}
          - template: azure-pipeline-templates/frontendtest.yml
            parameters:
              authorize: STAGING_AUTHORIZATION
              baseUrl: https://int.campaignresources.dhsc.gov.uk
              tags: ${{ parameters.tags }}

      - job: deployStaging
        displayName: Deploy Staging
        condition: or(startsWith(variables['Build.SourceBranch'], 'refs/tags/'), ${{ parameters.deployStaging }})
        variables:
          - group: Staging
        steps:
          - template: azure-pipeline-templates/run-init-container-app-job.yml
            parameters:
              env: stag
              version: $(sourceBranchName)
              dryrun: ${{ parameters.dryrun }}
          - template: azure-pipeline-templates/deploy-container-app-revision.yml
            parameters:
              env: stag
              version: $(sourceBranchName)
              dryrun: ${{ parameters.dryrun }}
          - template: azure-pipeline-templates/frontendtest.yml
            parameters:
              authorize: STAGING_AUTHORIZATION
              baseUrl: https://staging.campaignresources.dhsc.gov.uk
              tags: ${{ parameters.tags }}

  - stage: deployProduction
    displayName: Deploy Production
    condition: or(and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/tags/')), ${{ parameters.deployProduction }})
    dependsOn: Deploy
    jobs:
      - deployment: approval
        environment: production
      - job: deployProduction
        variables:
          - group: Production
        steps:
          - template: azure-pipeline-templates/run-init-container-app-job.yml
            parameters:
              env: prod
              version: $(sourceBranchName)
              dryrun: ${{ parameters.dryrun }}
          - template: azure-pipeline-templates/deploy-container-app-revision.yml
            parameters:
              env: prod
              version: $(sourceBranchName)
              dryrun: ${{ parameters.dryrun }}
          - template: azure-pipeline-templates/frontendtest.yml
            parameters:
              baseUrl: https://campaignresources.dhsc.gov.uk
              tags: ${{ parameters.tags }}

  - stage: deployDr
    displayName: Deploy DR
    condition: or(and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/tags/')), ${{ parameters.deployDr }})
    dependsOn: Deploy
    jobs:
      - deployment: approval
        environment: production
      - job: deployDr
        steps:
          - template: azure-pipeline-templates/run-init-container-app-job.yml
            parameters:
              env: prod
              region: ukw
              version: $(sourceBranchName)
              dryrun: ${{ parameters.dryrun }}
          - template: azure-pipeline-templates/deploy-container-app-revision.yml
            parameters:
              env: prod
              region: ukw
              version: $(sourceBranchName)
              dryrun: ${{ parameters.dryrun }}

  - stage: DailyBuildAlert
    displayName: Daily Build alerting
    dependsOn:
      - PrepareAndTest
      - Build
      - Deploy
    condition: and(eq(variables['Build.Reason'], 'Schedule'), ne(variables.notificationSlackWebhook, ''), or(failed('PrepareAndTest'), failed('Build'), failed('Deploy')))
    variables:
      - group: alerting
    jobs:
      - job: Alert
        displayName: Daily Build Slack Alert
        steps:
          - script: |
              echo "Sending slack alert for daily build failure"
              messageText=":warning: *CRC - Daily Build Failure*\nSee the <$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)&_a=summary|build pipeline run> for details"
              body="{\"text\": \"$messageText\", \"mrkdwn\": true}"
              curl -X POST -H 'Content-type: application/json' --data "$body" $(notificationSlackWebhook)
            displayName: Send Slack Alert
