parameters:
  artifactPath:       '' # working directory
  environment:        '' # env name for resource tags
  azureSubscription:  '' # the service connection in the pipeline
  resourceGroup:      '' # name of the resource group which contains the TF resources
  tfStorageAccount:   '' # name of the storage account which stores the TF state
  importArgs:         ' ' # comma separated list of resources to import in 'azurerm_instance.tf_name | <instance id>, ...' form


steps:

  - task: ms-devlabs.custom-terraform-tasks.custom-terraform-installer-task.TerraformInstaller@0
    displayName: 'Install latest Terraform'
    inputs:
      terraformVersion: latest

  - task: JasonBJohnson.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
    displayName: 'terraform init'
    inputs:
      command: init
      workingDirectory: ${{ parameters.artifactPath }}
      backendType: azurerm
      backendServiceArm: ${{ parameters.azureSubscription }}
      backendAzureRmResourceGroupName: ${{ parameters.resourceGroup }}
      backendAzureRmStorageAccountName: ${{ parameters.tfStorageAccount }}
      backendAzureRmContainerName: tfstate
      backendAzureRmKey: terraform.tfstate

  - task: JasonBJohnson.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
    displayName: 'terraform validate'
    inputs:
      workingDirectory: ${{ parameters.artifactPath }}


  - ${{ if and(ne(parameters.importArgs, ''), ne(parameters.importArgs, ' ')) }}:
    - ${{ each resourceDetails in split(replace(parameters.importArgs, ' ', ''), ',')}}:
      - task: Bash@3
        name: ShowImports
        displayName: 'Check import inputs'
        inputs:
          targetType: 'inlineScript'
          script: |
            echo "importArgs: ${{ parameters.importArgs }}"
            echo "resourceDetails: ${{ resourceDetails }}"
            echo "resourceAddress: ${{ split(resourceDetails, '|')[0] }}"
            echo "resourceId: ${{ split(resourceDetails, '|')[1] }}"

  - ${{ if and(ne(parameters.importArgs, ''), ne(parameters.importArgs, ' ')) }}:
    - ${{ each resourceDetails in split(replace(parameters.importArgs, ' ', ''), ',')}}:
      - task: TerraformCLI@0
        displayName: "terraform import state for ${{ split(resourceDetails, '|')[0] }}"
        inputs:
          command: import
          workingDirectory: ${{ parameters.artifactPath }}
          resourceAddress: ${{ split(resourceDetails, '|')[0] }}
          resourceId: ${{ split(resourceDetails, '|')[1] }}

  - task: JasonBJohnson.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
    displayName: 'terraform plan'
    inputs:
      command: plan
      workingDirectory: ${{ parameters.artifactPath }}
      environmentServiceName: ${{ parameters.azureSubscription }}
      commandOptions: >
        -var resource_group=${{ parameters.resourceGroup }}
        -var environment=${{ parameters.environment }}
        -var tfstate_account_name=${{ parameters.tfStorageAccount }}

  - task: JasonBJohnson.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
    displayName: 'terraform apply'
    inputs:
      command: apply
      workingDirectory: ${{ parameters.artifactPath }}
      environmentServiceName: ${{ parameters.azureSubscription }}
      commandOptions: >
        -var resource_group=${{ parameters.resourceGroup }}
        -var environment=${{ parameters.environment }}
        -var tfstate_account_name=${{ parameters.tfStorageAccount }}

  - task: AzureCLI@2
    displayName: Azure CLI check secrets
    condition: succeededOrFailed()
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        requiredSecretsNotYetFound=("alertingWebhook" "pubToken" "pubEndpoint" "searchIndexEndpoint")

        secretIds=$(az keyvault secret list --vault-name ${{ replace(parameters.resourceGroup, '-rg-', '-kv-') }} --query [].id)
        secretIds=$(echo $secretIds | jq -c '.[]' | awk '{gsub(/"/,"")}1')
        foundSecrets=""
        emptySecrets=""

        for secretId in ${secretIds[@]};
        do  
          secretName=$(echo $secretId | awk -F'/' '{print $NF}')
          secretValue=$(az keyvault secret show --id $secretId --query value)
          secretValue=$(echo $secretValue | awk '{gsub(/"/,"")}1')
          if [[ $secretValue == '' ]];
          then
            echo "WARNING: $secretName has no value"
            emptySecrets="${emptySecrets} ${secretName}"
          else
            echo "SUCCESS: $secretName has a value"
          fi

          new_array=()
          for requiredSecret in "${requiredSecretsNotYetFound[@]}"
          do
              [[ $requiredSecret != $secretName ]] && new_array+=("$requiredSecret")
          done
          requiredSecretsNotYetFound=("${new_array[@]}")
          unset new_array
        done
        
        if [[ $emptySecrets != '' ]];
        then
          echo "##vso[task.logissue type=warning;]Empty secrets found in ${{ replace(parameters.resourceGroup, '-rg-', '-kv-') }}: [$emptySecrets ]"
          echo "##vso[task.complete result=SucceededWithIssues;]"
        fi
        
        if [[ ${#requiredSecretsNotYetFound[@]} != 0 ]];
        then
          echo "##vso[task.logissue type=warning;]Required secrets not found in ${{ replace(parameters.resourceGroup, '-rg-', '-kv-') }}: [ ${requiredSecretsNotYetFound[*]} ]"
          echo "##vso[task.complete result=SucceededWithIssues;]"
        fi
